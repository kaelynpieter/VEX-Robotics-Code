#pragma config(Sensor, dgtl1,  topstop,        sensorTouch)
#pragma config(Sensor, dgtl2,  botstop,        sensorTouch)
#pragma config(Sensor, dgtl3,  Chassis1,       sensorQuadEncoder)
#pragma config(Sensor, dgtl5,  Chassis2,       sensorQuadEncoder)
#pragma config(Sensor, dgtl7,  Lift,           sensorQuadEncoder)
#pragma config(Sensor, dgtl9,  bot2stop,       sensorTouch)
#pragma config(Sensor, dgtl10, color,          sensorTouch)
#pragma config(Sensor, dgtl11, side,           sensorTouch)
#pragma config(Motor,  port1,           rightTop,      tmotorVex393_HBridge, openLoop, reversed)
#pragma config(Motor,  port2,           r1,            tmotorVex393_MC29, openLoop, reversed)
#pragma config(Motor,  port3,           r2,            tmotorVex393_MC29, openLoop, reversed, encoderPort, dgtl5)
#pragma config(Motor,  port4,           r3,            tmotorVex393_MC29, openLoop, reversed)
#pragma config(Motor,  port5,           l3,            tmotorVex393_MC29, openLoop)
#pragma config(Motor,  port6,           l2,            tmotorVex393_MC29, openLoop, encoderPort, dgtl3)
#pragma config(Motor,  port7,           l1,            tmotorVex393_MC29, openLoop)
#pragma config(Motor,  port8,           claw,          tmotorVex393_MC29, openLoop)
#pragma config(Motor,  port9,           leftBoth,      tmotorVex393_MC29, openLoop)
#pragma config(Motor,  port10,          rightBot,      tmotorVex393_HBridge, openLoop)
//*!!Code automatically generated by 'ROBOTC' configuration wizard               !!*//

/*---------------------------------------------------------------------------*/
/*                                                                           */
/*        Description: Competition template for VEX EDR                      */
/*                                                                           */
/*---------------------------------------------------------------------------*/

// This code is for the VEX cortex platform
#pragma platform(VEX2)

// Select Download method as "competition"
#pragma competitionControl(Competition)

//Main competition background code...do not modify!
#include "Vex_Competition_Includes.c"

/*---------------------------------------------------------------------------*/
/*                          Pre-Autonomous Functions                         */
/*                                                                           */
/*  You may want to perform some actions before the competition starts.      */
/*  Do them in the following function.  You must return from this function   */
/*  or the autonomous and usercontrol tasks will not be started.  This       */
/*  function is only called once after the cortex has been powered on and    */
/*  not every time that the robot is disabled.                               */
/*---------------------------------------------------------------------------*/
int oneinch = 75/2;
int onedegree = 225/100;
int hold = 0;
int conecount = 1;
int judge = 0;


void drive(int speed, int goal)
{
	//Reset Motor Encoders
	SensorValue[Chassis1] = 0;
	SensorValue[Chassis2] = 0;
	while( abs(SensorValue[Chassis1]) < (oneinch * goal) && abs(SensorValue[Chassis2]) < (oneinch * goal))
	{

		motor[r1] = speed;
		motor[r2] = speed;
		motor[r3] = speed;
		motor[l1] = speed;
		motor[l2] = speed;
		motor[l3] = speed;
	}

	motor[r1] = 0;
	motor[r2] = 0;
	motor[r3] = 0;
	motor[l1] = 0;
	motor[l2] = 0;
	motor[l3] = 0;
	wait(0.05);
}

void turn(int speed1, int degree)// Left is positive and right is negative
{
	SensorValue[Chassis1] = 0;
	SensorValue[Chassis2] = 0;
	while(abs(SensorValue[Chassis1]) < (degree * onedegree) && abs(SensorValue[Chassis1]) < (degree * onedegree))
	{
		motor[r1] = speed1;
		motor[r2] = speed1;
		motor[r3] = speed1;
		motor[l1] = -speed1;
		motor[l2] = -speed1;
		motor[l3] = -speed1;
	}
	motor[r1] = 0;
	motor[r2] = 0;
	motor[r3] = 0;
	motor[l1] = 0;
	motor[l2] = 0;
	motor[l3] = 0;
	wait(0.05);
}

void liftup(int autocone)
{

	if(autocone == 1)
	{
		motor[leftBoth] = 0;
		motor[rightBot] = 0;
		motor[rightTop] = 0;
		while(SensorValue[Lift] < 5)
		{
			motor[leftBoth] = -80;
			motor[rightBot] = 80;
			motor[rightTop] = 80;
		}
		motor[leftBoth] = 0;
		motor[rightBot] = 0;
		motor[rightTop] = 0;
	}
	else if(autocone == 0)
	{
		hold = 1;
		motor[leftBoth] = -35;
		motor[rightBot] = 35;
		motor[rightTop] = 35;

	}
	else if(autocone == -1)
	{
		hold = 1;
		motor[leftBoth] = -45;
		motor[rightBot] = 45;
		motor[rightTop] = 45;

	}
}

void liftdown()
{
	if(hold ==0)
	{
		while(SensorValue[Lift] > 8)
		{
			motor[leftBoth] = 80;
			motor[rightBot] = -80;
			motor[rightTop] = -80;
		}
		motor[leftBoth] = 0;
		motor[rightBot] = 0;
		motor[rightTop] = 0;
	}
	else if(hold == 1)
	{
		hold = 0;
		motor[leftBoth] = 0;
		motor[rightBot] = 0;
		motor[rightTop] = 0;
	}
}

void begin()
{
	motor[claw] = -65;
	wait(0.1);
	motor[claw] = 0;
}
void openclaw()
{
	motor[claw] = 0;
	motor[claw] = -65;
	wait(0.75);
	motor[claw] = 0;
}

void closeclaw()
{
	motor[claw] = 0;
	motor[claw] = 65;
	wait(0.75);
	motor[claw] = 0;
}
void holdclaw(int holdon)
{
	if(holdon == 1)
	{
		motor[claw] = 40;
	}
	else if(holdon == 0)
	{
		motor[claw] = 0;
	}
}
void redleft()
{
	begin();
	wait(0.1);
	closeclaw();
	drive(115, 20);
	openclaw();
	wait(0.1);
	drive(115, 12);
	closeclaw();
	holdclaw(1);
	liftup(0);
	turn(100, 10);
	drive(-115,17);
	wait(0.1);
	turn(-115, 240);
	wait(0.1);
	liftup(-1);
	drive(115, 34);
	liftdown();
	openclaw();
	wait(0.2);
	liftdown();
	drive(-115, 10);
}
void blueright()
{
	begin();
	wait(0.1);
	closeclaw();
	drive(115, 20);
	openclaw();
	wait(0.1);
	drive(115, 13);
	closeclaw();
	holdclaw(1);
	liftup(0);
	turn(-100, 10);
	drive(-115, 21);
	wait(0.1);
	turn(115, 295);
	wait(0.2);
	liftup(-1);
	drive(115, 31);
	liftdown();
	openclaw();
	wait(0.2);
	liftdown();
	drive(-115, 10);
}
void redright()
{
	drive(115,25);
	begin();
	drive(115,4);
	closeclaw();
	holdclaw(1);
	liftup(0);
	drive(-115, 29);
	wait(0.1);
	turn(115, 295);
	liftup(-1);
	wait(0.1);
	drive(115, 24);
	liftdown();
	openclaw();
	wait(0.2);
	liftdown();
	drive(-115, 10);
}
void blueleft()
{
	drive(115,25);
	begin();
	drive(115,5);
	closeclaw();
	holdclaw(1);
	liftup(0);
	drive(-115, 29);
	wait(0.1);
	turn(-115, 252);
	liftup(-1);
	wait(0.1);
	drive(115, 24);
	liftdown();
	openclaw();
	wait(0.2);
	liftdown();
	drive(-115, 10);
}

void pre_auton()
{
	// Set bStopTasksBetweenModes to false if you want to keep user created tasks
	// running between Autonomous and Driver controlled modes. You will need to
	// manage all user created tasks if set to false.
	bStopTasksBetweenModes = true;

	// Set bDisplayCompetitionStatusOnLcd to false if you don't want the LCD
	// used by the competition include file, for example, you might want
	// to display your team name on the LCD in this function.
	// bDisplayCompetitionStatusOnLcd = false;

	// All activities that occur before the competition starts
	// Example: clearing encoders, setting servo positions, ...
}


/*                              Autonomous Task                              */
//Task Autonomous: Duration: 0:15
task autonomous()
{
	if(SensorValue[side] == 1 && SensorValue[color] == 1)
	{
		redright();
	}
	else if(SensorValue[side] == 0 && SensorValue[color] == 1)
	{
		redleft();
	}
	else if(SensorValue[side] == 0 && SensorValue[color] == 0)
	{
		blueleft();
	}
	else if(SensorValue[side] == 1 && SensorValue[color] == 0)
	{
		blueright();
	}

}
/*                             User Control Task                             */
//Task User Control: Duration 1:45
task usercontrol()
{


	while(true)
	{
		//Chassis joystick control
		motor[r1] = vexRT[Ch2]*19/20;
		motor[r2] = vexRT[Ch2]*19/20;
		motor[r3] = vexRT[Ch2]*19/20;
		motor[l3] = vexRT[Ch3]*19/20;
		motor[l2] = vexRT[Ch3]*19/20;
		motor[l1] = vexRT[Ch3]*19/20;


		//Lift control
		if(SensorValue[topstop]==0 && vexRT[Btn5UXmtr2] == 1)
		{
			motor[leftBoth] = -100;
			motor[rightBot] = 100;
			motor[rightTop] = 100;
		}

		else if(vexRT[Btn5DXmtr2] == 1)
		{
			if(SensorValue[botstop]==0 && SensorValue[bot2stop]==0)
			{
				motor[leftBoth] = 100;
				motor[rightBot] = -100;
				motor[rightTop] = -100;
			}
			else if(SensorValue[botstop]==1 || SensorValue[bot2stop]==1)
			{
				motor[leftBoth] = 0;
				motor[rightBot] = 0;
				motor[rightTop] = 0;
				wait(0.1);
			}
		}
		else
		{
			motor[leftBoth] = 0;
			motor[rightBot] = 0;
			motor[rightTop] = 0;
		}


		//claw
		if(vexRT[Btn6UXmtr2] == 1)
		{
			motor[claw] = 85;
		}
		else if(vexRT[Btn6DXmtr2]== 1)
		{
			motor[claw] = 0;
			motor[claw] = -100;
		}

		else
		{
			motor[claw] = 0;
		}
	}
}

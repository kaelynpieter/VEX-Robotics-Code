#pragma config(Sensor, dgtl1,  rightt,         sensorTouch)
#pragma config(Sensor, dgtl2,  leftt,          sensorTouch)
#pragma config(Sensor, dgtl3,  Chassis1,       sensorQuadEncoder)
#pragma config(Sensor, dgtl5,  Chassis2,       sensorQuadEncoder)
#pragma config(Sensor, dgtl7,  rightb,         sensorTouch)
#pragma config(Sensor, dgtl8,  leftb,          sensorTouch)
#pragma config(Sensor, dgtl9,  chain,          sensorQuadEncoder)
#pragma config(Sensor, dgtl11, mogo,           sensorQuadEncoder)
#pragma config(Motor,  port1,           mogo1,         tmotorVex393_HBridge, openLoop)
#pragma config(Motor,  port2,           r1,            tmotorVex393HighSpeed_MC29, openLoop, reversed)
#pragma config(Motor,  port3,           r2,            tmotorVex393HighSpeed_MC29, openLoop)
#pragma config(Motor,  port4,           r3,            tmotorVex393HighSpeed_MC29, openLoop, reversed)
#pragma config(Motor,  port5,           fourbar,       tmotorVex393HighSpeed_MC29, openLoop)
#pragma config(Motor,  port6,           l2,            tmotorVex393HighSpeed_MC29, openLoop, reversed)
#pragma config(Motor,  port7,           l1,            tmotorVex393HighSpeed_MC29, openLoop)
#pragma config(Motor,  port8,           l3,            tmotorVex393HighSpeed_MC29, openLoop)
#pragma config(Motor,  port9,           chainbar,      tmotorVex393_MC29, openLoop)
#pragma config(Motor,  port10,          claw,          tmotorVex393_HBridge, openLoop, reversed)
//*!!Code automatically generated by 'ROBOTC' configuration wizard               !!*//

//																				2496N BHS Robopatties																						//
//																			 Code For Robot Version 2			 																		//
//																				 	 Competition File																							//

//Place Intergers Here
int oneinch = 75/4;
int onedegree = 218/100;
//Place Functions Here
void drive(int speed, int goal)
{
	//Reset Motor Encoders
	SensorValue[Chassis1] = 0;
	SensorValue[Chassis2] = 0;
	while(abs(SensorValue[Chassis1]) < (oneinch * goal)  && abs(SensorValue[Chassis2]) < (oneinch * goal))
	{
		motor[r1] = speed;
		motor[r2] = speed;
		motor[r3] = speed;
		motor[l1] = speed;
		motor[l2] = speed;
		motor[l3] = speed;
	}
	motor[r1] = 0;
	motor[r2] = 0;
	motor[r3] = 0;
	motor[l1] = 0;
	motor[l2] = 0;
	motor[l3] = 0;
	wait(0.05);
}
void turn(int speed1, int degree)// Left is positive and right is negative
{
	SensorValue[Chassis1] = 0;
	SensorValue[Chassis2] = 0;
	while(abs(SensorValue[Chassis1]) < (degree * onedegree)  && abs(SensorValue[Chassis2]) < (degree * onedegree))
	{
		motor[r1] = speed1;
		motor[r2] = speed1;
		motor[r3] = speed1;
		motor[l1] = -speed1;
		motor[l2] = -speed1;
		motor[l3] = -speed1;
	}
	motor[r1] = 0;
	motor[r2] = 0;
	motor[r3] = 0;
	motor[l1] = 0;
	motor[l2] = 0;
	motor[l3] = 0;
	wait(0.05);
}

void runmogo(int inout)
{
	SensorValue[mogo] = 0;
	motor[mogo1] = 0;
	clearTimer(T1);
	while(abs(SensorValue[mogo]) < 137 && time1[T1] < 2500)
	{
		motor[mogo1] = inout;
	}
	motor[mogo1] = 15;
	wait(0.05);
}
void runmogo1(int inout1)
{
	SensorValue[mogo] = 0;
	motor[mogo1] = 0;
	clearTimer(T1);
	while(abs(SensorValue[mogo]) < 130 && time1[T1] < 2500)
	{
		motor[mogo1] = inout1;
	}
	motor[mogo1] = 15;
	wait(0.05);
}

void goliathin()
{
	motor[claw] = 127;
	wait(0.5);
	motor[claw] = 0;
	wait(0.05);
}

void goliathout()
{
	motor[claw] = -127;
	wait(0.5);
	motor[claw] = 0;
	wait(0.05);
}
void goliathhold()
{
	motor[claw] = 35;
	wait(0.05);
}
void chainauto(int run)//postive in and negative out
{
	motor[chainbar] = 0;
	SensorValue[chain] = 0;
	clearTimer(T1);
	while(abs(SensorValue[chain]) < 380 && time1[T1] < 2500)
	{
		motor[chainbar] = run;
	}
	motor[chainbar] = 15;
	wait(0.05);
}
void chainup(int run1)//postive in and negative out
{
	motor[chainbar] = 0;
	SensorValue[chain] = 0;
	clearTimer(T1);
	while(abs(SensorValue[chain]) < 164 && time1[T1] < 2500)
	{
		motor[chainbar] = run1;
	}
	motor[chainbar] = -10;
	wait(0.05);
}

//Choose Your Auto
void redloader5()//Scores in the five point with preload cone
{
	goliathhold();
	chainup(-60);
	wait(0.5);
	runmogo(105);
	drive(127, 58);
	runmogo1(-105);
	chainauto(120);
	drive(-120, 35);
	wait(0.5);
	turn(80, 45);
	drive(-120,13);
	turn(100, 110);
	goliathout();
	chainup(-60);
	drive(-127,2);
	runmogo(105);
	drive(-127,15);
}
void blueloader5()//Scores in the five point with preload cone
{
	goliathhold();
	chainup(-60);
	wait(0.5);
	runmogo(105);
	drive(120, 59);
	runmogo1(-105);
	chainauto(120);
	drive(-120, 35);
	wait(0.5);
	turn(-85, 35);
	drive(-120,5);
	wait(0.5);
	turn(-80, 70);
	goliathout();
	chainup(-60);
	runmogo(105);
	drive(-127,10);
}
void redcone5()//Scores in the five point with preload cone
{
	goliathhold();
	chainup(-60);
	wait(0.5);
	runmogo(105);
	drive(120, 61);
	runmogo1(-105);
	chainauto(120);
	drive(-120, 41);
	wait(0.5);
	turn(-85, 30);
	drive(-120,7);
	wait(0.5);
	turn(-80, 65);
	goliathout();
	chainup(-60);
	drive(127,1);
	runmogo(105);
	drive(-127,15);
}
void bluecone5()//Scores in the five point with preload cone
{
	goliathhold();
	chainup(-65);
	wait(0.5);
	runmogo(120);
	drive(120, 58);
	runmogo1(-105);
	chainauto(120);
	drive(-120, 36);
	wait(0.5);
	turn(80, 45);
	drive(-120,15);
	turn(100, 118);
	goliathout();
	chainup(-60);
	drive(-127,2);
	runmogo(105);
	drive(-127,15);
}

void redloader10()//Scores in the ten point zone with preload
{
	goliathhold();
	chainup(-60);
	wait(0.5);
	runmogo(105);
	drive(127, 58);
	runmogo1(-105);
	chainauto(120);
	drive(-120, 35);
	wait(0.5);
	turn(80, 45);
	drive(-120,14);
	turn(100, 105);
	goliathout();
	chainup(-60);
	drive(127,6);
	runmogo(105);
	drive(-127,15);
}
void blueloader10()//Scores in the ten point zone with preload
{
	goliathhold();
	chainup(-60);
	wait(0.5);
	runmogo(105);
	drive(120, 59);
	runmogo1(-105);
	chainauto(120);
	drive(-120, 35);
	wait(0.5);
	turn(-85, 35);
	drive(-120,9);
	wait(0.5);
	turn(-80, 55);
	goliathout();
	chainup(-60);
	drive(127,11);
	runmogo(105);
	drive(-127,15);
}
void bluecone10()//Scores in the ten point zone with preload
{
	goliathhold();
	chainup(-60);
	wait(0.5);
	runmogo(120);
	drive(120, 58);
	runmogo1(-105);
	chainauto(120);
	drive(-120, 36);
	wait(0.5);
	turn(80, 45);
	drive(-120,15);
	turn(100, 118);
	goliathout();
	chainup(-60);
	drive(127,8);
	runmogo(105);
	drive(-127,15);
}
void redcone10()//Scores in the ten point zone with preload
{
	goliathhold();
	chainup(-60);
	wait(0.5);
	runmogo(105);
	drive(120, 61);
	runmogo1(-105);
	chainauto(120);
	drive(-120, 41);
	wait(0.5);
	turn(-85, 30);
	drive(-120,7);
	wait(0.5);
	turn(-80, 65);
	goliathout();
	chainup(-60);
	drive(127, 10);
	runmogo(105);
	drive(-127,15);
}


#pragma platform(VEX2)
#pragma competitionControl(Competition)
#include "Vex_Competition_Includes.c"
void pre_auton()
{
	// Set bStopTasksBetweenModes to false if you want to keep user created tasks
	// running between Autonomous and Driver controlled modes. You will need to
	// manage all user created tasks if set to false.
	bStopTasksBetweenModes = true;
}
/*                              Autonomous Task                              */
//Task Autonomous: Duration: 0:15
task autonomous()
{
	blueloader10();
}

/*                             User Control Task                             */
//Task User Control: Duration 1:45

task usercontrol()
{
	while(true)
	{
		// &&

		if(vexRT[Btn6U] == 1)
		{
			//Chassis Immobilizer
			motor[r1] = -10;
			motor[r2] = -10;
			motor[r3] = -10;
			motor[l3] = -10;
			motor[l2] = -10;
			motor[l1] = -10;
		}
		else
		{
			//Chassis Joystick Control
			motor[r1] = vexRT[Ch2]*4/3;
			motor[r2] = vexRT[Ch2]*4/3;
			motor[r3] = vexRT[Ch2]*4/3;
			motor[l3] = vexRT[Ch3]*4/3;
			motor[l2] = vexRT[Ch3]*4/3;
			motor[l1] = vexRT[Ch3]*4/3;
		}

		//Mobile Goal 4-Bar Lift
		if(vexRT[Btn5D] == 1)
		{
			motor[mogo1] = 105;
		}
		else if(vexRT[Btn5U] == 1)
		{
			motor[mogo1] = -105;
		}
		else if(vexRT[Btn6D] == 1)
		{
			motor[mogo1] = 15;
		}
		else
		{
			motor[mogo1] = 0;
		}

		//4-Bar Cone Lift
		if(SensorValue[rightt] == 1 && SensorValue[leftt] == 1 && vexRT[Ch3Xmtr2]  >= 0)
		{
			motor[fourbar] = 10;
		}
		else if((SensorValue[rightb] == 1 || SensorValue[leftb] == 1) && vexRT[Ch3Xmtr2]  <= 0)
		{
			motor[fourbar] = 0;
		}
		else
		{
			motor[fourbar] = vexRT[Ch3Xmtr2]*4/3;
		}

		//Chainbar Cone Lift
		motor[chainbar] = vexRT[Ch2Xmtr2]*4/3;

		//Goliath
		if(vexRT[Btn6UXmtr2] == 1)
		{
			motor[claw] = -127;
		}
		else if(vexRT[Btn6DXmtr2] == 1)
		{
			motor[claw] = 127;
		}
		else if(vexRT[Btn5UXmtr2] == 1)
		{
			motor[claw] = 15;
		}
		else
		{
			motor[claw] = 0;
		}
	}
}

#pragma config(Sensor, dgtl1,  wolverine,      sensorQuadEncoder)
#pragma config(Sensor, dgtl3,  lift,           sensorQuadEncoder)
#pragma config(Sensor, dgtl5,  rquad,          sensorQuadEncoder)
#pragma config(Sensor, dgtl7,  lquad,          sensorQuadEncoder)
#pragma config(Sensor, dgtl9,  redcapb,        sensorTouch)
#pragma config(Sensor, dgtl10, rednetb,        sensorTouch)
#pragma config(Sensor, dgtl11, bluecapb,       sensorTouch)
#pragma config(Sensor, dgtl12, bluenetb,       sensorTouch)
#pragma config(Motor,  port1,           intake,        tmotorVex393_HBridge, openLoop, reversed)
#pragma config(Motor,  port2,           left1,         tmotorVex393HighSpeed_MC29, openLoop, reversed)
#pragma config(Motor,  port3,           left2,         tmotorVex393HighSpeed_MC29, openLoop)
#pragma config(Motor,  port4,           left3,         tmotorVex393HighSpeed_MC29, openLoop)
#pragma config(Motor,  port5,           liftr,         tmotorVex393HighSpeed_MC29, openLoop)
#pragma config(Motor,  port6,           liftl,         tmotorVex393HighSpeed_MC29, openLoop)
#pragma config(Motor,  port7,           right1,        tmotorVex393HighSpeed_MC29, openLoop, reversed)
#pragma config(Motor,  port8,           right2,        tmotorVex393HighSpeed_MC29, openLoop, reversed)
#pragma config(Motor,  port9,           right3,        tmotorVex393HighSpeed_MC29, openLoop, reversed)
//*!!Code automatically generated by 'ROBOTC' configuration wizard               !!*//

/*---------------------------------------------------------------------------*/
/*                                                                           */
/*        					 This is Team 2496R's Version 1 Code                     */
/*        					   Important Lift Information Below:                     */
/*                              Lift1=Normal                                 */
/*                              Lift2=Reversed                               */
/*                              Lift3=Normal                                 */
/*                              Lift4=Reversed                               */
/*---------------------------------------------------------------------------*/


#pragma platform(VEX2)
#pragma competitionControl(Competition)
#include "Vex_Competition_Includes.c"
/*---------------------------------------------------------------------------*/
/*                          Integers Named Below                             */
/*---------------------------------------------------------------------------*/
//Lift Values
int maxheight = 507;
int smallpostheight = 264;
int tallpostheight = 392;
float liftkP = 3.1;
float liftkI = 0.07;
float liftkD = 0.04;
int errorlift = 0;
int lastlifterror = 0;
int liftgoal = 0;
int powerlift =  0;
int cumerrorlift = 0;
int derivativelift = 0;
bool pidStatusLift = true;
int position = 1;
//Intake
float intakekP = 2.1;
float intakekI = 0.1;
float intakekD = 0.12;
int error = 0;
int lasterror = 0;
int intakegoal = 0;
int power =  0;
int cumerror = 0;
int derivative = 0;
bool pidStatusClaw = true;
int position1 = 0;
//Chassis
float oneinch = 22.88;
float onedegree = 1.28;

//Auton Functions Below
void unfold()
{
	clearTimer(T1);
	SensorValue[wolverine] = 0;
	while(SensorValue[wolverine] < 7 && time1[T1] < 2000)
	{
		motor[intake] = 50;
	}
	motor[intake] = 0;
	wait(0.5);
	while(SensorValue[wolverine] > -62 && time1[T1] < 2000)
	{
		motor[intake] = -50;
	}
	motor[intake] = -10;
	wait(0.1);
	motor[intake] = 0;

	SensorValue[wolverine] = 180;

}
void drive(int speed, float goal)
{
	//Reset Motor Encoders
	clearTimer(T1);
	SensorValue[lquad] = 0;
	SensorValue[rquad] = 0;
	while(abs(SensorValue[rquad]) < (oneinch * goal)  && abs(SensorValue[lquad]) < (oneinch * goal)&& time1[T1] < 2000)
	{
		motor[left1] = speed;
		motor[left2] = speed;
		motor[left3] = speed;
		motor[right1] = speed;
		motor[right2] = speed;
		motor[right3] = speed;

	}
	motor[left1] = -15;
	motor[left2] = -15;
	motor[left3] = -15;
	motor[right1] = -15;
	motor[right2] = -15;
	motor[right3] = -15;
	wait(0.1);
	motor[left1] = 0;
	motor[left2] = 0;
	motor[left3] = 0;
	motor[right1] = 0;
	motor[right2] = 0;
	motor[right3] = 0;
	wait(0.05);
}
void turn(int speed1, float degree)// Left is positive and right is negative
{
	SensorValue[lquad] = 0;
	SensorValue[rquad] = 0;
	clearTimer(T1);
	while(abs(SensorValue[rquad]) < (degree * onedegree)  && abs(SensorValue[lquad]) < (degree * onedegree)&& time1[T1] < 2000)
	{
		motor[left1] = -speed1;
		motor[left2] = -speed1;
		motor[left3] = -speed1;
		motor[right1] = speed1;
		motor[right2] = speed1;
		motor[right3] = speed1;
	}
	motor[left1] = -15;
	motor[left2] = -15;
	motor[left3] = -15;
	motor[right1] = -15;
	motor[right2] = -15;
	motor[right3] = -15;
	wait(0.1);
	motor[left1] = 0;
	motor[left2] = 0;
	motor[left3] = 0;
	motor[right1] = 0;
	motor[right2] = 0;
	motor[right3] = 0;
	wait(0.05);
}
void liftcontrol(int speed2, int choice)// Positive Up- negative Down
{
	SensorValue[lquad] = 0;
	SensorValue[rquad] = 0;
	clearTimer(T1);
	if(choice == 1)
	{

		while(abs(SensorValue[rquad]) < (smallpostheight)  && abs(SensorValue[lquad]) < (smallpostheight)&& time1[T1] < 2000)
		{
			motor[left1] = -speed2;
			motor[left2] = -speed2;
			motor[left3] = -speed2;
			motor[right1] = speed2;
			motor[right2] = speed2;
			motor[right3] = speed2;
		}
	}
	else if(choice == 2)
	{

		while(abs(SensorValue[rquad]) < (tallpostheight)  && abs(SensorValue[lquad]) < (tallpostheight) && time1[T1] < 2000)
		{
			motor[left1] = -speed2;
			motor[left2] = -speed2;
			motor[left3] = -speed2;
			motor[right1] = speed2;
			motor[right2] = speed2;
			motor[right3] = speed2;
		}
	}
	motor[left1] = -15;
	motor[left2] = -15;
	motor[left3] = -15;
	motor[right1] = -15;
	motor[right2] = -15;
	motor[right3] = -15;
	wait(0.1);
	motor[left1] = 0;
	motor[left2] = 0;
	motor[left3] = 0;
	motor[right1] = 0;
	motor[right2] = 0;
	motor[right3] = 0;
	wait(0.05);
}
//Actual Autons Below
void redcap()
{
	motor[liftl] = -10;
	motor[liftr] = -10;
	drive(-30, 39);
	drive(70, 50);
	wait(2);
	drive(-49, 30);
	turn(70, 162);
	wait(0.1);
	drive(-78, 34);
	unfold();
}
void bluecap()
{
	motor[liftl] = -10;
	motor[liftr] = -10;
	drive(-30, 40);
	drive(50, 50);
	wait(2);
	drive(-50, 29);
	wait(0.1);
	turn(-70, 210);
	wait(0.1);
	drive(-78, 34);
	unfold();
}
void rednet()
{
	motor[liftl] = -10;
	motor[liftr] = -10;
	drive(-60, 50);
	drive(60, 53);
	turn(-70, 120);
	wait(0.1);
	drive(-30, 41);
	drive(50, 50);
	wait(0.1);
	drive(-49, 27);
	turn(-80, 162);
	wait(0.1);
	drive(-76, 35);
	unfold();
}
void bluenet()
{
	motor[liftl] = 15;
	motor[liftr] = 15;
	unfold();
	motor[liftl] = -10;
	motor[liftr] = -10;
	drive(-60, 60);
	drive(55, 58);
	turn(60, 102);
	wait(0.1);
	drive(-31, 44);
	drive(50, 53);
	wait(0.1);
	drive(-50, 28);
	turn(80, 155);
	wait(0.1);
	drive(-80, 33);


}
/*---------------------------------------------------------------------------*/
/*                          Pre-Autonomous Functions                         */
/*                                                                           */
/*  You may want to perform some actions before the competition starts.      */
/*  Do them in the following function.  You must return from this function   */
/*  or the autonomous and usercontrol tasks will not be started.  This       */
/*  function is only called once after the cortex has been powered on and    */
/*  not every time that the robot is disabled.                               */
/*---------------------------------------------------------------------------*/

void pre_auton()
{
	// Set bStopTasksBetweenModes to false if you want to keep user created tasks
	// running between Autonomous and Driver controlled modes. You will need to
	// manage all user created tasks if set to false.
	bStopTasksBetweenModes = true;

}

/*---------------------------------------------------------------------------*/
/*                                                                           */
/*                              Autonomous Task                              */
/*                                                                           */
/*  This task is used to control your robot during the autonomous phase of   */
/*  a VEX Competition.                                                       */
/*                                                                           */
/*  You must modify the code to add your own robot specific commands here.   */
/*---------------------------------------------------------------------------*/


task autonomous()
{
	//Kaelyn, in autonmous you need to set the wolverine intake up for driving
	//and you need to set the position value at the end
	SensorValue[wolverine] =0;
	SensorValue[lift] =0;
	SensorValue[rquad] =0;
	SensorValue[lquad] =0;
	SensorValue[lquad] = 0;
	SensorValue[rquad] = 0;
	if(SensorValue[redcapb] == 1)
	{
		redcap();
	}
	else if(SensorValue[rednetb] == 1)
	{
		rednet();
	}
	else if(SensorValue[bluecapb] == 1)
	{
		bluecap();
	}
	else if(SensorValue[bluenetb] == 1)
	{
		bluenet();
	}
	else
	{
		unfold();
	}

}

/*---------------------------------------------------------------------------*/
/*                                                                           */
/*                              User Control Task                            */
/*                                                                           */
/*  This task is used to control your robot during the user control phase of */
/*  a VEX Competition.                                                       */
/*                                                                           */
/*  You must modify the code to add your own robot specific commands here.   */
/*---------------------------------------------------------------------------*/
task clawPID()
{
	SensorValue[wolverine] = 0;
	while(true)
	{
		if(pidStatusClaw == true)
		{
			lasterror = error;
			error = intakegoal-SensorValue[wolverine];
			if(abs(error)<36)
			{
				cumerror = cumerror + error;
			}
			else if(abs(error) > 100)
			{
				cumerror = 0;
			}
			derivative = (error - lasterror);
			power = (error*intakekP) + (cumerror*intakekI) + (derivative*intakekD);
			motor[intake] = power;
			waitInMilliseconds(15);
		}
	}
}

task liftPID()
{
	SensorValue[lift] = 0;
	while(true)
	{
		if(pidStatusLift == true)
		{
			lastlifterror = errorlift;
			errorlift = liftgoal-SensorValue[lift];
			if(abs(errorlift)<36)
			{
				cumerrorlift = cumerrorlift + errorlift;
			}
			else if(abs(errorlift) > 100)
			{
				cumerrorlift = 0;
			}
			derivativelift = (errorlift - lastlifterror);
			powerlift = (errorlift*liftkP) + (cumerrorlift*liftkI) + (derivativelift*liftkD);
			if(powerlift < 90)
			{
				motor[liftl] = powerlift;
				motor[liftr] = powerlift;
			}
			else
			{
				motor[liftl] = 91;
				motor[liftr] = 91;
			}
			waitInMilliseconds(15);
		}
	}
}


task usercontrol()
{
	SensorValue[wolverine] =0;
	SensorValue[lift] =0;
	SensorValue[rquad] =0;
	SensorValue[lquad] =0;
	startTask(clawPID);
	startTask(liftPID);
	while(true)
	{
		//Chassis Code: Tank Drive
		if(vexRT[Ch3] > 20 || vexRT[Ch3] < -20)
		{
			motor[left1] = vexRT[Ch3]*5/6;
			motor[left2] = vexRT[Ch3]*5/6;
			motor[left3] = vexRT[Ch3]*5/6;
		}
		else
		{
			motor[left1] = 0;
			motor[left2] = 0;
			motor[left3] = 0;
		}
		if(vexRT[Ch2] > 20 || vexRT[Ch2] < -20)
		{
			motor[right1] = vexRT[Ch2]*5/6;
			motor[right2] = vexRT[Ch2]*5/6;
			motor[right3] = vexRT[Ch2]*5/6;
		}
		else
		{
			motor[right1] = 0;
			motor[right2] = 0;
			motor[right3] = 0;
		}


		//Lift Code: 6U goes up, 6D does down
		if(vexRT[Btn6U] == 1)
		{
			pidStatusLift = true;
			if(position == 1)
			{
				liftgoal = smallpostheight;
				while(vexRT[Btn6U] == 1)
				{
					position = 2;
				}
			}
			else if(position == 2)
			{
				liftgoal = tallpostheight;
				while(vexRT[Btn6U] == 1)
				{
					position = 3;
				}
			}
			else
			{
				liftgoal = maxheight;
			}

		}
		else if(vexRT[Btn5D] == 1)
		{
			if(pidStatusLift == true)
			{
				wait(0.075);
				liftgoal = liftgoal-2;
			}
			else if(pidStatusLift == false)
			{
				motor[liftl] = -15;
				motor[liftr] = -15;
			}
		}
		else if(vexRT[Btn6D] == 1)
		{
			pidStatusLift = false;
			position = 1;
			motor[liftl] = -60;
			motor[liftr] = -60;
		}
		else
		{
			if(pidStatusLift == false)
			{
				motor[liftr] = 0;
				motor[liftl] = 0;
			}
		}

		//Intake Code: 5U turns
		if(vexRT[Btn5U] == 1 )
		{
			if(pidStatusClaw == true)
			{
				if(position1 == 0)
				{
					intakegoal = 180;
					while(vexRT[Btn5U] == 1)
					{
						position1 = 1;
					}
				}
				else if(position1 == 1)
				{
					intakegoal = 0;
					while(vexRT[Btn5U] == 1)
					{
						position1 = 0;
					}
				}
			}
			else
			{
				motor[intake] = 30;
			}
		}
		else
		{
			if(pidStatusClaw == false)
			{
				motor[intake] = 0;
			}
		}

		//PID control for both Lift and Intake
		if(vexRT[Btn8U] == 1)
		{
			if(pidStatusClaw == true)
			{
				pidStatusClaw = false;
				while(vexRT[Btn8U] == 1){}
			}
			else if(pidStatusClaw == false)
			{
				pidStatusClaw = true;
				while(vexRT[Btn8U] == 1){}
			}
		}
		else{}
		if(vexRT[Btn8R] == 1)
		{
			SensorValue[wolverine] = 0;
		}
		else{}
		if(vexRT[Btn7U] == 1)
		{
			if(pidStatusLift == true)
			{
				pidStatusLift = false;
				while(vexRT[Btn7U] == 1){}
			}
			else if(pidStatusLift == false)
			{
				pidStatusLift = true;
				while(vexRT[Btn7U] == 1){}
			}

		}
		else{}
		if(vexRT[Btn7L] == 1)
		{
			SensorValue[lift] = 0;
		}
		else{}

		if(vexRT[Btn8L] == 1)
		{

			pidStatusClaw = false;
			clearTimer(T1);
			SensorValue[wolverine] = 0;
			while(SensorValue[wolverine] < 7 && time1[T1] < 2000)
			{
				motor[intake] = 50;
			}
			motor[intake] = 0;
			wait(0.5);
			while(SensorValue[wolverine] > -62 && time1[T1] < 2000)
			{
				motor[intake] = -50;
			}
			motor[intake] = -10;
			wait(0.1);
			motor[intake] = 0;

			SensorValue[wolverine] = 180;
			pidStatusClaw = true;
		}
		else{}
	}
}
